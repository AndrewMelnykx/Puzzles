// Are you familiar with the rules of hooks in React?

// How would one optimise the performance of React contexts to reduce rerenders?

// How do you ensure that a component can be unit tested?

// what benefits do functional components provide vs class components?

// what are the use cases for using useCallback, useMemo and useEffect?

// How would you reference and interact with a DOM element in React without the use of document functions such as getElementById or querySelector?

// Explain and tell me the difference between render props, higher order components, prop getters. What problem are they trying to solve?

// React 18 introduced some changes to strict mode when in development mode, what are they and what is their purpose?

// how would you set the state in a callback based on the current value of that state, without adding it to a dependency array?

// How would you ensure that separate state changes are triggered in a synchronous manner?

// when testing a component, what knowledge should the component have or not have? How do you ensure it's a unit test and not an integration test?

// What do you think about test coverage as a metric for test quality?

// How would you split a component to encapsulate business logic and presentation concerns? How would the tests for these look like?

// Why is lifting state up a bad practice?

// What can you tell me about composability vs inheritance in React?

// If you had a Web application written in an old frontend framework for example, what strategy would you take to migrating that application to React?

// what is the difference between a primitive and non-primitive value in JavaScript, and how would you handle extra rerender caused by having non-primative values in a dependency array in the various hooks React has to offer?

// what is the difference between useEffect and useLayoutEffect?

// what reserved prop in React allows you to trigger a rerender in that component?

// We also have a React coding assessment that they do beforehand, and we talk about what they did and they screen share their code:

// if you had more time, what would you improve in your test?

// How would you approach following SOLID principals to reduce the complexity of the god component you created?

// what steps would you take to incorporate exception handling in your data fetching logic?

// If a new requirement came in to implement a new type of modal, what changes would you make to you modal implementation to cater for it?

// How would you eliminate memory leaks when dealing with your debounce function?

// What approach would you take to avoid prop drilling down the component hierarchy to some deeply nested component?

// If a new requirement came in to improve the performance of the list of data returned by the API, what approach would you take to alleviate pressure on the DOM?

// Familiarity with optimizing inputs (especially, inputs that transfer data to child components - how to reduce child re-renders).

// Understanding when a component re-renders, and what are the ways to reduce re-rendering.

// How to avoid memory leaks when working with asynchronous code (especially timeouts).

// How useEffect works - in-depth, when it triggers, how it performs the equality check, which dependencies can be omitted, and why (this is often related to in-depth knowledge of react hooks such as useState).

// Which fields (including hooks, and functions) change their memory reference once a component re-renders, and how to keep the initial reference using React core mechanisms.

// Which fields (including hooks, and functions) change their memory reference once a component re-renders, and how to keep the initial reference using React core mechanisms.

// Understanding throttling and debouncing. How could you implement debouncing using React hooks, and a callback approach? Differences between these two approaches? How could you utilize one of them to optimize code?
